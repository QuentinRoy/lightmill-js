/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Experiment Logging Service
 * OpenAPI spec version: 3.0
 */
import { z } from 'zod';

export const experimentGetCollectionQueryParams = z.object({
  'filter[name]': z.string().or(z.array(z.string())).optional(),
});

export const experimentGetCollectionResponse = z.object({
  data: z.array(
    z.object({
      type: z.enum(['experiments']),
      id: z.string(),
      attributes: z.object({ name: z.string().min(1) }),
    }),
  ),
});

export const experimentPostBody = z.object({
  data: z.object({
    type: z.enum(['experiments']),
    attributes: z.object({ name: z.string().min(1) }),
  }),
});

export const experimentGetSingleParams = z.object({ id: z.string() });

export const experimentGetSingleResponse = z.object({
  data: z.object({
    type: z.enum(['experiments']),
    id: z.string(),
    attributes: z.object({ name: z.string().min(1) }),
  }),
});

/**
 * Get all logs, optionally filtered using query parameters.
Defaults to CSV format so `Accept` header is required to get JSON.
 */
export const logGetCollectionQueryParams = z.object({
  'filter[logType]': z.string().or(z.array(z.string())).optional(),
  'filter[experiment.id]': z.string().or(z.array(z.string())).optional(),
  'filter[experiment.name]': z.string().or(z.array(z.string())).optional(),
  'filter[run.name]': z.string().or(z.array(z.string())).optional(),
  'filter[run.id]': z.string().or(z.array(z.string())).optional(),
  include: z
    .enum(['run', 'run.experiment', 'run.lastLogs'])
    .or(z.array(z.enum(['run', 'run.experiment', 'run.lastLogs'])))
    .optional(),
});

export const logGetCollectionHeader = z.object({
  accept: z.string().optional(),
});

export const logGetCollectionResponse = z.object({
  data: z.array(
    z.object({
      type: z.enum(['logs']),
      id: z.string(),
      attributes: z.object({
        logType: z
          .string()
          .describe(
            'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
          ),
        number: z
          .number()
          .min(1)
          .describe(
            'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
          ),
        values: z
          .object({})
          .describe(
            'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
          ),
      }),
      relationships: z.object({
        run: z.object({
          data: z.object({ type: z.enum(['runs']), id: z.string() }),
        }),
      }),
    }),
  ),
  included: z
    .array(
      z
        .object({
          type: z.enum(['runs']),
          id: z.string(),
          attributes: z.object({
            name: z.string().or(z.null()),
            status: z
              .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
              .describe(
                "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
              ),
            lastLogNumber: z.number(),
            missingLogNumbers: z.array(z.number()),
          }),
          relationships: z.object({
            experiment: z.object({
              data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
            }),
            lastLogs: z.object({
              data: z.array(
                z.object({ id: z.string(), type: z.enum(['logs']) }),
              ),
            }),
          }),
        })
        .or(
          z.object({
            type: z.enum(['experiments']),
            id: z.string(),
            attributes: z.object({ name: z.string().min(1) }),
          }),
        )
        .or(
          z.object({
            type: z.enum(['logs']),
            id: z.string(),
            attributes: z.object({
              logType: z
                .string()
                .describe(
                  'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe "trial", "event", etc.',
                ),
              number: z
                .number()
                .min(1)
                .describe(
                  'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
                ),
              values: z
                .object({})
                .describe(
                  'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
                ),
            }),
            relationships: z.object({
              run: z.object({
                data: z.object({ type: z.enum(['runs']), id: z.string() }),
              }),
            }),
          }),
        ),
    )
    .optional(),
});

export const logPostBody = z.object({
  data: z.object({
    type: z.enum(['logs']),
    attributes: z.object({
      logType: z
        .string()
        .describe(
          'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
        ),
      number: z
        .number()
        .min(1)
        .describe(
          'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
        ),
      values: z
        .object({})
        .describe(
          'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
        ),
    }),
    relationships: z.object({
      run: z.object({
        data: z.object({ type: z.enum(['runs']), id: z.string() }),
      }),
    }),
  }),
});

export const logGetSingleParams = z.object({ id: z.string() });

export const logGetSingleQueryParams = z.object({
  include: z
    .enum(['run', 'run.experiment', 'run.lastLogs'])
    .or(z.array(z.enum(['run', 'run.experiment', 'run.lastLogs'])))
    .optional(),
});

export const logGetSingleResponse = z.object({
  data: z.object({
    type: z.enum(['logs']),
    id: z.string(),
    attributes: z.object({
      logType: z
        .string()
        .describe(
          'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
        ),
      number: z
        .number()
        .min(1)
        .describe(
          'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
        ),
      values: z
        .object({})
        .describe(
          'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
        ),
    }),
    relationships: z.object({
      run: z.object({
        data: z.object({ type: z.enum(['runs']), id: z.string() }),
      }),
    }),
  }),
});

export const runPostBody = z.object({
  data: z.object({
    type: z.enum(['runs']),
    attributes: z.object({
      name: z.string().or(z.null()),
      status: z
        .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
        .describe(
          "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
        ),
    }),
    relationships: z.object({
      experiment: z.object({
        data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
      }),
    }),
  }),
});

export const runGetCollectionQueryParams = z.object({
  'filter[experiment.id]': z.string().or(z.array(z.string())).optional(),
  'filter[experiment.name]': z.string().or(z.array(z.string())).optional(),
  'filter[id]': z.string().or(z.array(z.string())).optional(),
  'filter[name]': z.string().or(z.array(z.string())).optional(),
  'filter[status]': z
    .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
    .describe(
      "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
    )
    .or(
      z.array(
        z
          .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
          .describe(
            "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
          ),
      ),
    )
    .optional(),
  include: z
    .array(z.enum(['experiment', 'lastLogs']))
    .or(z.enum(['experiment', 'lastLogs']))
    .optional(),
});

export const runGetCollectionResponse = z.object({
  data: z.array(
    z.object({
      type: z.enum(['runs']),
      id: z.string(),
      attributes: z.object({
        name: z.string().or(z.null()),
        status: z
          .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
          .describe(
            "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
          ),
        lastLogNumber: z.number(),
        missingLogNumbers: z.array(z.number()),
      }),
      relationships: z.object({
        experiment: z.object({
          data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
        }),
        lastLogs: z.object({
          data: z.array(z.object({ id: z.string(), type: z.enum(['logs']) })),
        }),
      }),
    }),
  ),
  included: z
    .array(
      z
        .object({
          type: z.enum(['experiments']),
          id: z.string(),
          attributes: z.object({ name: z.string().min(1) }),
        })
        .or(
          z.object({
            type: z.enum(['logs']),
            id: z.string(),
            attributes: z.object({
              logType: z
                .string()
                .describe(
                  'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
                ),
              number: z
                .number()
                .min(1)
                .describe(
                  'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
                ),
              values: z
                .object({})
                .describe(
                  'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
                ),
            }),
            relationships: z.object({
              run: z.object({
                data: z.object({ type: z.enum(['runs']), id: z.string() }),
              }),
            }),
          }),
        ),
    )
    .optional(),
});

export const runGetSingleParams = z.object({ id: z.string() });

export const runGetSingleQueryParams = z.object({
  include: z
    .array(z.enum(['experiment', 'lastLogs']))
    .or(z.enum(['experiment', 'lastLogs']))
    .optional(),
});

export const runGetSingleResponse = z.object({
  data: z.object({
    type: z.enum(['runs']),
    id: z.string(),
    attributes: z.object({
      name: z.string().or(z.null()),
      status: z
        .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
        .describe(
          "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
        ),
      lastLogNumber: z.number(),
      missingLogNumbers: z.array(z.number()),
    }),
    relationships: z.object({
      experiment: z.object({
        data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
      }),
      lastLogs: z.object({
        data: z.array(z.object({ id: z.string(), type: z.enum(['logs']) })),
      }),
    }),
  }),
  included: z
    .array(
      z
        .object({
          type: z.enum(['experiments']),
          id: z.string(),
          attributes: z.object({ name: z.string().min(1) }),
        })
        .or(
          z.object({
            type: z.enum(['logs']),
            id: z.string(),
            attributes: z.object({
              logType: z
                .string()
                .describe(
                  'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
                ),
              number: z
                .number()
                .min(1)
                .describe(
                  'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
                ),
              values: z
                .object({})
                .describe(
                  'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
                ),
            }),
            relationships: z.object({
              run: z.object({
                data: z.object({ type: z.enum(['runs']), id: z.string() }),
              }),
            }),
          }),
        ),
    )
    .optional(),
});

export const runPatchParams = z.object({ id: z.string() });

export const runPatchBody = z.object({
  data: z.object({
    type: z.enum(['runs']),
    id: z.string(),
    attributes: z
      .object({
        name: z.string().or(z.null()).optional(),
        status: z
          .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
          .optional()
          .describe(
            "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
          ),
        lastLogNumber: z.number().optional(),
        missingLogNumbers: z.array(z.number()).optional(),
      })
      .optional(),
  }),
});

export const runPatchResponse = z.object({
  data: z.object({
    type: z.enum(['runs']),
    id: z.string(),
    attributes: z.object({
      name: z.string().or(z.null()),
      status: z
        .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
        .describe(
          "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
        ),
      lastLogNumber: z.number(),
      missingLogNumbers: z.array(z.number()),
    }),
    relationships: z.object({
      experiment: z.object({
        data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
      }),
      lastLogs: z.object({
        data: z.array(z.object({ id: z.string(), type: z.enum(['logs']) })),
      }),
    }),
  }),
});

export const sessionPostHeader = z.object({
  authorization: z.string().optional(),
});

export const sessionPostBody = z.object({
  data: z.object({ type: z.enum(['sessions']) }),
});

export const sessionGetParams = z.object({ id: z.string() });

export const sessionGetQueryParams = z.object({
  include: z
    .array(z.enum(['runs', 'runs.experiment', 'runs.lastLogs']))
    .or(z.enum(['runs', 'runs.experiment', 'runs.lastLogs']))
    .optional(),
});

export const sessionGetResponse = z.object({
  data: z.object({ type: z.enum(['sessions']), id: z.string() }),
  included: z
    .array(
      z
        .object({
          type: z.enum(['runs']),
          id: z.string(),
          attributes: z.object({
            name: z.string().or(z.null()),
            status: z
              .enum(['idle', 'running', 'completed', 'interrupted', 'canceled'])
              .describe(
                "The status of a run.\n- `idle` means that the run has not started yet. It may be started, or\ncanceled.\n- `running` means that the run is currently running. It may be interrupted,\ncanceled, or completed later.\n- `completed` means that the run has been completed. It may not be resumed,\ninterrupted, or canceled anymore.\n- `interrupted` means that the run has been interrupted, is not currently\nrunning, but hasn't been completed yet. It may be resumed later.\n- `canceled` means that the run has been canceled. It may not be resumed,\ninterrupted, or completed anymore. This status make it possible to\nrecreate the run (i.e. start a new run with the same name for the same\nexperiment).",
              ),
            lastLogNumber: z.number(),
            missingLogNumbers: z.array(z.number()),
          }),
          relationships: z.object({
            experiment: z.object({
              data: z.object({ id: z.string(), type: z.enum(['experiments']) }),
            }),
            lastLogs: z.object({
              data: z.array(
                z.object({ id: z.string(), type: z.enum(['logs']) }),
              ),
            }),
          }),
        })
        .or(
          z.object({
            type: z.enum(['logs']),
            id: z.string(),
            attributes: z.object({
              logType: z
                .string()
                .describe(
                  'The type of the log. This is not the same as the resource type (which is always \"logs\" for\nlogs). This is a type that describes the kind of log. For example, it could\nbe \"trial\", \"event\", etc.',
                ),
              number: z
                .number()
                .min(1)
                .describe(
                  'The number of the log. This is a number that is unique for the run\nthe log belongs to. Log numbers must be sequential and start at 1.\nLogs must not necessarily be created in order, but any missing log\nmust be created before the run is completed, and any log\nfollowing a missing log is considered pending.',
                ),
              values: z
                .object({})
                .describe(
                  'The log values. They may be any JSON object. However, it is recommended\nto use flat objects as nested objects are difficult to serialize to CSV.\nIt is also recommended to use a consistent schema for all logs of the\nsame type.',
                ),
            }),
            relationships: z.object({
              run: z.object({
                data: z.object({ type: z.enum(['runs']), id: z.string() }),
              }),
            }),
          }),
        )
        .or(
          z.object({
            type: z.enum(['experiments']),
            id: z.string(),
            attributes: z.object({ name: z.string().min(1) }),
          }),
        ),
    )
    .optional(),
});

export const sessionDeleteParams = z.object({ id: z.string() });

export const sessionDeleteResponse = z.object({ data: z.null() });
